; --index-fresh-sorts --proof-version=2 --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=30
(set-option :produce-proofs true)
(set-logic AUFLIRA)
(declare-sort Int_real_real_real_prod_fun_prod_set$ 0)
(declare-sort Real_real_prod_real_real_prod_fun_set$ 0)
(declare-fun c$ () Real_real_prod_real_real_prod_fun_set$)
(declare-fun finite$ (Real_real_prod_real_real_prod_fun_set$) Bool)
(declare-fun finite$a (Int_real_real_real_prod_fun_prod_set$) Bool)
(declare-fun boundary_chain$ (Int_real_real_real_prod_fun_prod_set$) Bool)
(declare-fun chain_subdiv_chain$ (Int_real_real_real_prod_fun_prod_set$ Int_real_real_real_prod_fun_prod_set$) Bool)
(declare-fun common_sudiv_exists$ (Int_real_real_real_prod_fun_prod_set$ Int_real_real_real_prod_fun_prod_set$) Bool)
(declare-fun two_chain_horizontal_boundary$ (Real_real_prod_real_real_prod_fun_set$) Int_real_real_real_prod_fun_prod_set$)
(declare-fun common_boundary_sudivision_exists$ (Int_real_real_real_prod_fun_prod_set$ Int_real_real_real_prod_fun_prod_set$) Bool)
(assert (! (not (common_sudiv_exists$ (two_chain_horizontal_boundary$ c$) (two_chain_horizontal_boundary$ c$))) :named a0))
(assert (! (common_sudiv_exists$ (two_chain_horizontal_boundary$ c$) (two_chain_horizontal_boundary$ c$)) :named a1))
(assert (! (finite$ c$) :named a2))
(assert (! (forall ((?v0 Int_real_real_real_prod_fun_prod_set$) (?v1 Int_real_real_real_prod_fun_prod_set$)) (= (common_sudiv_exists$ ?v0 ?v1) (common_sudiv_exists$ ?v1 ?v0))) :named a3))
(assert (! (forall ((?v0 Int_real_real_real_prod_fun_prod_set$) (?v1 Int_real_real_real_prod_fun_prod_set$)) (=> (common_sudiv_exists$ ?v0 ?v1) (common_sudiv_exists$ ?v1 ?v0))) :named a4))
(assert (! (forall ((?v0 Int_real_real_real_prod_fun_prod_set$) (?v1 Int_real_real_real_prod_fun_prod_set$)) (=> (common_boundary_sudivision_exists$ ?v0 ?v1) (common_sudiv_exists$ ?v0 ?v1))) :named a5))
(assert (! (forall ((?v0 Real_real_prod_real_real_prod_fun_set$)) (boundary_chain$ (two_chain_horizontal_boundary$ ?v0))) :named a6))
(assert (! (forall ((?v0 Int_real_real_real_prod_fun_prod_set$) (?v1 Int_real_real_real_prod_fun_prod_set$)) (= (common_boundary_sudivision_exists$ ?v0 ?v1) (common_boundary_sudivision_exists$ ?v1 ?v0))) :named a7))
(assert (! (forall ((?v0 Real_real_prod_real_real_prod_fun_set$)) (=> (finite$ ?v0) (finite$a (two_chain_horizontal_boundary$ ?v0)))) :named a8))
(assert (! (forall ((?v0 Int_real_real_real_prod_fun_prod_set$)) (=> (boundary_chain$ ?v0) (chain_subdiv_chain$ ?v0 ?v0))) :named a9))
(check-sat)
;;;;(get-proof)
