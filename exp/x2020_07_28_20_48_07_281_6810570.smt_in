; --proof-with-sharing --index-fresh-sorts --proof-define-skolems --proof-prune --proof-merge --disable-print-success --disable-banner --max-time=3
(set-option :produce-proofs true)
(set-logic AUFLIA)
(declare-sort A$ 0)
(declare-sort S$ 0)
(declare-sort Nat$ 0)
(declare-sort A_set$ 0)
(declare-sort S_list$ 0)
(declare-sort S_a_fun$ 0)
(declare-sort S_bool_fun$ 0)
(declare-sort A_s_a_fun_fun$ 0)
(declare-sort A_literal_multiset$ 0)
(declare-sort Nat_s_bool_fun_fun$ 0)
(declare-sort A_literal_multiset_list$ 0)
(declare-sort S_a_literal_multiset_fun$ 0)
(declare-sort A_literal_multiset_bool_fun$ 0)
(declare-sort A_a_literal_multiset_a_fun_fun$ 0)
(declare-sort Nat_a_literal_multiset_bool_fun_fun$ 0)
(declare-sort A_literal_multiset_a_literal_multiset_fun$ 0)
(declare-sort A_literal_multiset_s_a_literal_multiset_fun_fun$ 0)
(declare-sort A_literal_multiset_a_literal_multiset_a_literal_multiset_fun_fun$ 0)
(declare-fun cs$ () A_literal_multiset_list$)
(declare-fun nth$ (A_literal_multiset_list$ Nat$) A_literal_multiset$)
(declare-fun less$ (Nat$ Nat$) Bool)
(declare-fun nth$a (S_list$ Nat$) S$)
(declare-fun size$ (A_literal_multiset_list$) Nat$)
(declare-fun size$a (S_list$) Nat$)
(declare-fun member$ (A$ A_set$) Bool)
(declare-fun thesis$ () Bool)
(declare-fun atms_of$ (A_literal_multiset$) A_set$)
(declare-fun fun_app$ (S_a_literal_multiset_fun$ S$) A_literal_multiset$)
(declare-fun sigma_s$ () S_list$)
(declare-fun fun_app$a (A_literal_multiset_s_a_literal_multiset_fun_fun$ A_literal_multiset$) S_a_literal_multiset_fun$)
(declare-fun fun_app$b (S_a_fun$ S$) A$)
(declare-fun fun_app$c (A_s_a_fun_fun$ A$) S_a_fun$)
(declare-fun fun_app$d (A_literal_multiset_a_literal_multiset_fun$ A_literal_multiset$) A_literal_multiset$)
(declare-fun fun_app$e (A_literal_multiset_a_literal_multiset_a_literal_multiset_fun_fun$ A_literal_multiset$) A_literal_multiset_a_literal_multiset_fun$)
(declare-fun fun_app$f (A_literal_multiset_bool_fun$ A_literal_multiset$) Bool)
(declare-fun fun_app$g (Nat_a_literal_multiset_bool_fun_fun$ Nat$) A_literal_multiset_bool_fun$)
(declare-fun fun_app$h (S_bool_fun$ S$) Bool)
(declare-fun fun_app$i (Nat_s_bool_fun_fun$ Nat$) S_bool_fun$)
(declare-fun subsumes$ (A_s_a_fun_fun$ A_literal_multiset$ A_literal_multiset$) Bool)
(declare-fun variants$ (A_s_a_fun_fun$ A_literal_multiset$ A_literal_multiset$) Bool)
(declare-fun subst_atm$ () A_s_a_fun_fun$)
(declare-fun subst_cls$ (A_s_a_fun_fun$) A_literal_multiset_s_a_literal_multiset_fun_fun$)
(declare-fun subst_cls$a (A_a_literal_multiset_a_fun_fun$) A_literal_multiset_a_literal_multiset_a_literal_multiset_fun_fun$)
(declare-fun generalizes$ (A_s_a_fun_fun$ A_literal_multiset$ A_literal_multiset$) Bool)
(declare-fun var_disjoint$ (A_s_a_fun_fun$ A_literal_multiset_list$) Bool)
(declare-fun is_ground_atm$ (A_s_a_fun_fun$ A$) Bool)
(declare-fun subseteq_mset$ (A_literal_multiset$ A_literal_multiset$) Bool)
(declare-fun var_disjoint$a (A_a_literal_multiset_a_fun_fun$ A_literal_multiset_list$) Bool)
(declare-fun is_ground_atms$ (A_s_a_fun_fun$ A_set$) Bool)
(declare-fun subst_cls_list$ (A_s_a_fun_fun$ A_literal_multiset_list$ S$) A_literal_multiset_list$)
(declare-fun generalizes_atm$ (A_s_a_fun_fun$ A$ A$) Bool)
(declare-fun renamings_apart$ (A_literal_multiset_list$) S_list$)
(declare-fun subst_cls_lists$ (A_s_a_fun_fun$ A_literal_multiset_list$ S_list$) A_literal_multiset_list$)
(declare-fun strictly_subsumes$ (A_s_a_fun_fun$ A_literal_multiset$ A_literal_multiset$) Bool)
(declare-fun strictly_generalizes$ (A_s_a_fun_fun$ A_literal_multiset$ A_literal_multiset$) Bool)
(declare-fun strictly_generalizes_atm$ (A_s_a_fun_fun$ A$ A$) Bool)
(assert (! (not thesis$) :named a0))
(assert (! (forall ((?v0 S$)) (=> (forall ((?v1 Nat$)) (=> (less$ ?v1 (size$ cs$)) (forall ((?v2 A_literal_multiset$)) (=> (subseteq_mset$ ?v2 (nth$ cs$ ?v1)) (= (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v2) (nth$a sigma_s$ ?v1)) (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v2) ?v0)))))) thesis$)) :named a1))
(assert (! (forall ((?v0 S$) (?v1 S$)) (=> (forall ((?v2 A$)) (= (fun_app$b (fun_app$c subst_atm$ ?v2) ?v0) (fun_app$b (fun_app$c subst_atm$ ?v2) ?v1))) (= ?v0 ?v1))) :named a2))
(assert (! (forall ((?v0 S$) (?v1 S$)) (= (= ?v0 ?v1) (forall ((?v2 A$)) (= (fun_app$b (fun_app$c subst_atm$ ?v2) ?v0) (fun_app$b (fun_app$c subst_atm$ ?v2) ?v1))))) :named a3))
(assert (! (= (size$a sigma_s$) (size$ cs$)) :named a4))
(assert (! (forall ((?v0 A_literal_multiset$) (?v1 A_literal_multiset$) (?v2 S$)) (=> (subseteq_mset$ ?v0 ?v1) (subseteq_mset$ (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v0) ?v2) (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v1) ?v2)))) :named a5))
(assert (! (var_disjoint$ subst_atm$ cs$) :named a6))
(assert (! (forall ((?v0 A$) (?v1 A$)) (= (generalizes_atm$ subst_atm$ ?v0 ?v1) (exists ((?v2 S$)) (= (fun_app$b (fun_app$c subst_atm$ ?v0) ?v2) ?v1)))) :named a7))
(assert (! (forall ((?v0 A_literal_multiset$) (?v1 A_literal_multiset$)) (= (subsumes$ subst_atm$ ?v0 ?v1) (exists ((?v2 S$)) (subseteq_mset$ (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v0) ?v2) ?v1)))) :named a8))
(assert (! (forall ((?v0 A_a_literal_multiset_a_fun_fun$)) (! (= (subst_cls$a ?v0) (subst_cls$a ?v0)) :pattern ((subst_cls$a ?v0)))) :named a9))
(assert (! (forall ((?v0 A_s_a_fun_fun$)) (! (= (subst_cls$ ?v0) (subst_cls$ ?v0)) :pattern ((subst_cls$ ?v0)))) :named a10))
(assert (! (forall ((?v0 A_literal_multiset$) (?v1 A_literal_multiset$)) (= (generalizes$ subst_atm$ ?v0 ?v1) (exists ((?v2 S$)) (= (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v0) ?v2) ?v1)))) :named a11))
(assert (! (forall ((?v0 A_literal_multiset_list$)) (= (var_disjoint$ subst_atm$ ?v0) (forall ((?v1 S_list$)) (=> (= (size$a ?v1) (size$ ?v0)) (exists ((?v2 S$)) (forall ((?v3 Nat$)) (=> (less$ ?v3 (size$ ?v0)) (forall ((?v4 A_literal_multiset$)) (=> (subseteq_mset$ ?v4 (nth$ ?v0 ?v3)) (= (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v4) (nth$a ?v1 ?v3)) (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v4) ?v2))))))))))) :named a12))
(assert (! (forall ((?v0 A$)) (= (is_ground_atm$ subst_atm$ ?v0) (forall ((?v1 S$)) (= ?v0 (fun_app$b (fun_app$c subst_atm$ ?v0) ?v1))))) :named a13))
(assert (! (forall ((?v0 A_a_literal_multiset_a_fun_fun$) (?v1 A_literal_multiset_list$)) (= (var_disjoint$a ?v0 ?v1) (forall ((?v2 A_literal_multiset_list$)) (=> (= (size$ ?v2) (size$ ?v1)) (exists ((?v3 A_literal_multiset$)) (forall ((?v4 Nat$)) (=> (less$ ?v4 (size$ ?v1)) (forall ((?v5 A_literal_multiset$)) (=> (subseteq_mset$ ?v5 (nth$ ?v1 ?v4)) (= (fun_app$d (fun_app$e (subst_cls$a ?v0) ?v5) (nth$ ?v2 ?v4)) (fun_app$d (fun_app$e (subst_cls$a ?v0) ?v5) ?v3))))))))))) :named a14))
(assert (! (forall ((?v0 A_s_a_fun_fun$) (?v1 A_literal_multiset_list$)) (= (var_disjoint$ ?v0 ?v1) (forall ((?v2 S_list$)) (=> (= (size$a ?v2) (size$ ?v1)) (exists ((?v3 S$)) (forall ((?v4 Nat$)) (=> (less$ ?v4 (size$ ?v1)) (forall ((?v5 A_literal_multiset$)) (=> (subseteq_mset$ ?v5 (nth$ ?v1 ?v4)) (= (fun_app$ (fun_app$a (subst_cls$ ?v0) ?v5) (nth$a ?v2 ?v4)) (fun_app$ (fun_app$a (subst_cls$ ?v0) ?v5) ?v3))))))))))) :named a15))
(assert (! (forall ((?v0 A_literal_multiset_list$) (?v1 A_literal_multiset_list$)) (=> (and (= (size$ ?v0) (size$ ?v1)) (forall ((?v2 Nat$)) (=> (less$ ?v2 (size$ ?v0)) (= (nth$ ?v0 ?v2) (nth$ ?v1 ?v2))))) (= ?v0 ?v1))) :named a16))
(assert (! (forall ((?v0 S_list$) (?v1 S_list$)) (=> (and (= (size$a ?v0) (size$a ?v1)) (forall ((?v2 Nat$)) (=> (less$ ?v2 (size$a ?v0)) (= (nth$a ?v0 ?v2) (nth$a ?v1 ?v2))))) (= ?v0 ?v1))) :named a17))
(assert (! (forall ((?v0 Nat$) (?v1 Nat_a_literal_multiset_bool_fun_fun$)) (= (forall ((?v2 Nat$)) (=> (less$ ?v2 ?v0) (exists ((?v3 A_literal_multiset$)) (fun_app$f (fun_app$g ?v1 ?v2) ?v3)))) (exists ((?v2 A_literal_multiset_list$)) (and (= (size$ ?v2) ?v0) (forall ((?v3 Nat$)) (=> (less$ ?v3 ?v0) (fun_app$f (fun_app$g ?v1 ?v3) (nth$ ?v2 ?v3)))))))) :named a18))
(assert (! (forall ((?v0 Nat$) (?v1 Nat_s_bool_fun_fun$)) (= (forall ((?v2 Nat$)) (=> (less$ ?v2 ?v0) (exists ((?v3 S$)) (fun_app$h (fun_app$i ?v1 ?v2) ?v3)))) (exists ((?v2 S_list$)) (and (= (size$a ?v2) ?v0) (forall ((?v3 Nat$)) (=> (less$ ?v3 ?v0) (fun_app$h (fun_app$i ?v1 ?v3) (nth$a ?v2 ?v3)))))))) :named a19))
(assert (! (forall ((?v0 A_literal_multiset_list$) (?v1 A_literal_multiset_list$)) (= (= ?v0 ?v1) (and (= (size$ ?v0) (size$ ?v1)) (forall ((?v2 Nat$)) (=> (less$ ?v2 (size$ ?v0)) (= (nth$ ?v0 ?v2) (nth$ ?v1 ?v2))))))) :named a20))
(assert (! (forall ((?v0 S_list$) (?v1 S_list$)) (= (= ?v0 ?v1) (and (= (size$a ?v0) (size$a ?v1)) (forall ((?v2 Nat$)) (=> (less$ ?v2 (size$a ?v0)) (= (nth$a ?v0 ?v2) (nth$a ?v1 ?v2))))))) :named a21))
(assert (! (forall ((?v0 A$) (?v1 A_literal_multiset$) (?v2 S$)) (=> (member$ ?v0 (atms_of$ ?v1)) (member$ (fun_app$b (fun_app$c subst_atm$ ?v0) ?v2) (atms_of$ (fun_app$ (fun_app$a (subst_cls$ subst_atm$) ?v1) ?v2))))) :named a22))
(assert (! (forall ((?v0 A_literal_multiset$)) (subseteq_mset$ ?v0 ?v0)) :named a23))
(assert (! (forall ((?v0 A_literal_multiset$)) (subseteq_mset$ ?v0 ?v0)) :named a24))
(assert (! (forall ((?v0 Nat$) (?v1 A_literal_multiset_list$) (?v2 S$)) (=> (less$ ?v0 (size$ ?v1)) (= (nth$ (subst_cls_list$ subst_atm$ ?v1 ?v2) ?v0) (fun_app$ (fun_app$a (subst_cls$ subst_atm$) (nth$ ?v1 ?v0)) ?v2)))) :named a25))
(assert (! (forall ((?v0 A_literal_multiset_list$) (?v1 S_list$) (?v2 Nat$)) (=> (and (= (size$ ?v0) (size$a ?v1)) (less$ ?v2 (size$ ?v0))) (= (nth$ (subst_cls_lists$ subst_atm$ ?v0 ?v1) ?v2) (fun_app$ (fun_app$a (subst_cls$ subst_atm$) (nth$ ?v0 ?v2)) (nth$a ?v1 ?v2))))) :named a26))
(assert (! (forall ((?v0 A_set$)) (= (is_ground_atms$ subst_atm$ ?v0) (forall ((?v1 A$)) (=> (member$ ?v1 ?v0) (is_ground_atm$ subst_atm$ ?v1))))) :named a27))
(assert (! (forall ((?v0 A_literal_multiset$) (?v1 A_literal_multiset$)) (! (= (variants$ subst_atm$ ?v0 ?v1) (and (generalizes$ subst_atm$ ?v0 ?v1) (generalizes$ subst_atm$ ?v1 ?v0))) :pattern ((variants$ subst_atm$ ?v0 ?v1)))) :named a28))
(assert (! (forall ((?v0 A_literal_multiset$) (?v1 A_literal_multiset$)) (! (= (strictly_generalizes$ subst_atm$ ?v0 ?v1) (and (generalizes$ subst_atm$ ?v0 ?v1) (not (generalizes$ subst_atm$ ?v1 ?v0)))) :pattern ((strictly_generalizes$ subst_atm$ ?v0 ?v1)))) :named a29))
(assert (! (forall ((?v0 A_literal_multiset$) (?v1 A_literal_multiset$)) (! (= (strictly_subsumes$ subst_atm$ ?v0 ?v1) (and (subsumes$ subst_atm$ ?v0 ?v1) (not (subsumes$ subst_atm$ ?v1 ?v0)))) :pattern ((strictly_subsumes$ subst_atm$ ?v0 ?v1)))) :named a30))
(assert (! (forall ((?v0 A_literal_multiset_list$) (?v1 S$)) (= (size$ (subst_cls_list$ subst_atm$ ?v0 ?v1)) (size$ ?v0))) :named a31))
(assert (! (forall ((?v0 A$) (?v1 A$)) (! (= (strictly_generalizes_atm$ subst_atm$ ?v0 ?v1) (and (generalizes_atm$ subst_atm$ ?v0 ?v1) (not (generalizes_atm$ subst_atm$ ?v1 ?v0)))) :pattern ((strictly_generalizes_atm$ subst_atm$ ?v0 ?v1)))) :named a32))
(assert (! (forall ((?v0 A_literal_multiset_list$)) (= (size$a (renamings_apart$ ?v0)) (size$ ?v0))) :named a33))
(assert (! (forall ((?v0 A_literal_multiset_list$)) (var_disjoint$ subst_atm$ (subst_cls_lists$ subst_atm$ ?v0 (renamings_apart$ ?v0)))) :named a34))
(check-sat)
;;;;(get-proof)
